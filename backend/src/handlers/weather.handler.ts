import type { Context } from "hono";    
import { WeatherEffectService, WEATHER_EFFECTS } from "../services/weatherEffectService/weatherEffectService.js";
import { asyncHandler } from '../utils/asyncWrapper.js';
import { ValidationError, ExternalServiceError } from '../models/errors.js';

// ‚úÖ Handlers refactoris√©s sans try/catch
export const getWeatherEffectsHandler = asyncHandler(async (c: Context) => {
  const lat = parseFloat(c.req.query('lat') || '48.8566');
  const lon = parseFloat(c.req.query('lon') || '2.3522');
  
  if (isNaN(lat) || isNaN(lon)) {
    throw new ValidationError('Coordonn√©es invalides');
  }
  
  console.log(`üåç R√©cup√©ration m√©t√©o pour coordonn√©es: ${lat}, ${lon}`);
  
  let weatherData;
  let effectCondition = 'ClearDay';
  
  // Essayer de r√©cup√©rer la vraie m√©t√©o
  const { WeatherService } = await import('../services/weatherService/weatherService.js');
  const weatherService = new WeatherService();
  weatherData = await weatherService.getWeatherByCoordinates(lat, lon);
  
  console.log('‚úÖ Donn√©es m√©t√©o OpenWeatherMap re√ßues:', weatherData);
  
  // ‚úÖ D√©terminer si c'est jour ou nuit bas√© sur l'ic√¥ne
  const isNight = weatherData.icon.endsWith('n');
  
  // ‚úÖ Mapper vers nos nouvelles conditions
  const conditionMapping: Record<string, string> = {
    'ciel d√©gag√©': isNight ? 'ClearNight' : 'ClearDay',
    'clear sky': isNight ? 'ClearNight' : 'ClearDay',
    'quelques nuages': 'Clouds',
    'few clouds': 'Clouds',
    'nuages √©pars': 'Clouds', 
    'scattered clouds': 'Clouds',
    'nuages fragment√©s': 'Clouds',
    'broken clouds': 'Clouds',
    'couvert': 'Clouds',
    'overcast clouds': 'Clouds',
    'l√©g√®re pluie': 'Rain',
    'light rain': 'Rain',
    'pluie mod√©r√©e': 'Rain',
    'moderate rain': 'Rain',
    'forte pluie': 'Rain',
    'heavy intensity rain': 'Rain',
    'neige': 'Snow',
    'snow': 'Snow',
    'orage': 'Thunderstorm',
    'thunderstorm': 'Thunderstorm'
  };
  
  effectCondition = conditionMapping[weatherData.description.toLowerCase()] || (isNight ? 'ClearNight' : 'ClearDay');
  
  // ‚úÖ Utiliser le nouveau syst√®me d'effets
  const effects = WeatherEffectService.getWeatherEffectByCondition(effectCondition);
  const timeBonus = WeatherEffectService.calculateTimeBonus();
  
  console.log('üéØ Effets calcul√©s:', effects);
  console.log('üåô Est-ce la nuit?', isNight);
  console.log('üîß Condition utilis√©e:', effectCondition);

  return c.json({
    success: true,
    location: weatherData.location,
    country: weatherData.country,
    temperature: weatherData.temperature,
    description: weatherData.description,
    humidity: weatherData.humidity,
    windSpeed: weatherData.windSpeed,
    icon: weatherData.icon,
    weather: { condition: effectCondition },
    effects,
    timeBonus
  });
});

export const simulateBattleHandler = asyncHandler(async (c: Context) => {
  const { attacker, defender, lat, lon } = await c.req.json();
  
  if (!attacker || !defender) {
    throw new ValidationError('Attaquant et d√©fenseur requis');
  }
  
  // ‚úÖ R√©cup√©rer les effets m√©t√©o
  const mockWeatherCondition = 'Rain'; // √Ä remplacer par votre API
  const effects = WeatherEffectService.getWeatherEffectByCondition(mockWeatherCondition);
  const timeBonus = WeatherEffectService.calculateTimeBonus();
  
  // ‚úÖ Calculer les stats avec m√©t√©o
  const finalAttacker = WeatherEffectService.calculatePokemonStats(attacker, effects, timeBonus);
  const finalDefender = WeatherEffectService.calculatePokemonStats(defender, effects, timeBonus);
  const typeEffectiveness = WeatherEffectService.calculateTypeEffectiveness(attacker.type, defender.type);
  
  // ‚úÖ Logique de combat simple
  const attackerScore = finalAttacker.effective_attack + finalAttacker.effective_speed;
  const defenderScore = finalDefender.effective_defense + finalDefender.effective_speed;
  const winner = attackerScore > defenderScore ? 'attacker' : 'defender';
  
  return c.json({
    success: true,
    battle: {
      winner,
      attackerStats: finalAttacker,
      defenderStats: finalDefender,
      typeEffectiveness,
      weatherEffects: effects
    }
  });
});